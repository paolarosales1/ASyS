
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>practica2</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-02-28"><meta name="DC.source" content="practica2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Practica 2: Se&ntilde;ales en tiempo discreto.</a></li><li><a href="#2">Introduccion</a></li><li><a href="#11">PROBLEMA 1</a></li><li><a href="#12">PARTE 1</a></li><li><a href="#13">PARTE 2</a></li><li><a href="#14">PARTE 3</a></li><li><a href="#15">PARTE 4</a></li><li><a href="#16">PARTE 5</a></li><li><a href="#17">PARTE 6</a></li><li><a href="#18">PARTE 7</a></li><li><a href="#19">Problema 2</a></li><li><a href="#20">Parte 1</a></li><li><a href="#21">Parte 2</a></li></ul></div><h2 id="1">Practica 2: Se&ntilde;ales en tiempo discreto.</h2><p>Integrantes:</p><div><ul><li>Betanzos Ferrando Melvin Emiliano</li></ul></div><div><ul><li>Garc&iacute;a Becerril Luis &Aacute;ngel Ian</li></ul></div><div><ul><li>Rosales Perez Paola Monserrat</li></ul></div><p>Grupo: 2MV1</p><pre class="codeinput"><span class="comment">%%Objetivos:</span>
<span class="comment">% Manipulaci&oacute;n b&aacute;sica de MATLAB</span>
<span class="comment">% Gr&aacute;ficas de se&ntilde;ales reales y complejas discretas</span>
<span class="comment">% Transformaci&oacute;n de se&ntilde;ales discretas (escalamientos y traslaciones</span>
</pre><h2 id="2">Introduccion</h2><p>El escalamiento horizontal es una operaci&oacute;n que se le aplica a una se&ntilde;al base para generar una se&ntilde;al nueva. Analiticamente un escalamiento horizontal tiene la forma:</p><p>g[n]=hEb{f[n]}=f[bn].</p><p>El escalamiento horizontal nos puede arrojar dos resulados, una compresi&oacute;n o una expansi&oacute;n de la se&ntilde;al. Visualmente se podria suponer que cuando vemos una expresi&oacute;n de este tipo f(n)=2n damos por hecho que la se&ntilde;al se duplicar&aacute;, sin embargo ocurre todo lo contrario. Si tenemos una b&gt;1 tendremos una compresi&oacute;n y esto implica que podamos tener una perdida de "datos", esta perdida de datos dependera del valor de b, ya que solo se conservaran las b-&eacute;simas muestras b+N, es decir solo multiplos de b.</p><p>A continuaci&oacute;n se muestra un ejemplo de escalonamiento cuando b&gt;1, en este caso se tiene una funci&oacute;n f(n)=n y con base en esta se busca generar una se&ntilde;al g(n)=f(2n).</p><pre class="codeinput">f=@(n) n.*(n&gt;=0);
figure
n=-10:10;
stem(n,f(n));
grid <span class="string">on</span>
ylabel(<span class="string">'f(n)'</span>)
xlabel(<span class="string">'n'</span>)
title(<span class="string">'Funci&oacute;n original f(n)=n'</span>)
g=@(n) (2.*n).*(2.*n&gt;=0);
figure
n=-10:10;
stem(n,g(n))
grid <span class="string">on</span>
ylabel(<span class="string">'g(n)'</span>)
xlabel(<span class="string">'n'</span>)
title(<span class="string">'Funci&oacute;n escalonada g(n)=2n'</span>)
</pre><img vspace="5" hspace="5" src="practica2_01.png" alt=""> <img vspace="5" hspace="5" src="practica2_02.png" alt=""> <p>Podemos ver como se pierde informaci&oacute;n de los valores n={3,5,7,..}.</p><p>Cuando 0&lt;b&lt;1 tenemos una expansi&oacute;n de la se&ntilde;al. Lo que sucede en estos casos es que se generan huecos en la se&ntilde;al, es decir, en vez de perder informaci&oacute;n nos faltaria informaci&oacute;n, esto ocurre debido a que si recordamos, las se&ntilde;ales discretas por norma se evaluan en valores enteros. Para ejemplificar este tipo de escalonamiento usaremos una funci&oacute;n h(n)=1 cuando se cumpla la siguiente condici&oacute;n: -3&lt;=n&lt;=1 y se busca hacer un escalamiento y(n)=h(0.5n).</p><pre class="codeinput">h=@(n) n.*(n&lt;=1);
figure
n=-5:5;
stem(n,h(n));
grid <span class="string">on</span>
ylabel(<span class="string">'h(n)'</span>)
xlabel(<span class="string">'n'</span>)
title(<span class="string">'Funci&oacute;n original h(n)=n'</span>)
y=@(n) ((0.5).*n).*(n&lt;=2);
figure
n=-5:5;
stem(n,y(n));
grid <span class="string">on</span>
ylabel(<span class="string">'y(n)'</span>)
xlabel(<span class="string">'n'</span>)
title(<span class="string">'Funci&oacute;n escalonada y(n)=n'</span>)
</pre><img vspace="5" hspace="5" src="practica2_03.png" alt=""> <img vspace="5" hspace="5" src="practica2_04.png" alt=""> <p>Podemos resaltar la informaci&oacute;n m&aacute;s importante en los siguientes puntos. *Se pierden datos cuando se comprime, s&oacute;lo podemos ver m&uacute;ltiplos del valor de compresi&oacute;n (siempre entero). * Cuando expandimos, tenemos la se&ntilde;al completa.</p><h2 id="11">PROBLEMA 1</h2><h2 id="12">PARTE 1</h2><p>Para x[n] grafique las siguientes se&ntilde;ales:</p><pre class="codeinput">x=@(t) ((t).*(t&gt;=0 ))
h=@(t) ((0).*(t&gt;3))
y=@(t) (((-t)+6).*(t&gt;=3))
t= (0:1:6);
hold <span class="string">off</span>
stem (t,x(t));
hold <span class="string">on</span>
stem (t,y(t));
hold <span class="string">off</span>
</pre><pre class="codeoutput">
x =

  function_handle with value:

    @(t)((t).*(t&gt;=0))


h =

  function_handle with value:

    @(t)((0).*(t&gt;3))


y =

  function_handle with value:

    @(t)(((-t)+6).*(t&gt;=3))

</pre><img vspace="5" hspace="5" src="practica2_05.png" alt=""> <h2 id="13">PARTE 2</h2><pre class="codeinput">x=@(t) ((t).*(t&gt;=0 ))
h=@(t) ((0).*(t&gt;3))
y=@(t) (((-t)+6).*(t&gt;=3))
t= (0:1:6);
hold <span class="string">off</span>
stem (t,x(-t));
hold <span class="string">on</span>
stem (t,y(-t));
hold <span class="string">off</span>
</pre><pre class="codeoutput">
x =

  function_handle with value:

    @(t)((t).*(t&gt;=0))


h =

  function_handle with value:

    @(t)((0).*(t&gt;3))


y =

  function_handle with value:

    @(t)(((-t)+6).*(t&gt;=3))

</pre><img vspace="5" hspace="5" src="practica2_06.png" alt=""> <h2 id="14">PARTE 3</h2><pre class="codeinput">x=@(t) ((t).*(t&gt;=0 ))
h=@(t) ((0).*(t&gt;3))
y=@(t) (((-t)+6).*(t&gt;=3))
t= (0:1:6);
hold <span class="string">off</span>
stem (t,x(t+6));
hold <span class="string">on</span>
stem (t,y(t+6));
hold <span class="string">off</span>
</pre><pre class="codeoutput">
x =

  function_handle with value:

    @(t)((t).*(t&gt;=0))


h =

  function_handle with value:

    @(t)((0).*(t&gt;3))


y =

  function_handle with value:

    @(t)(((-t)+6).*(t&gt;=3))

</pre><img vspace="5" hspace="5" src="practica2_07.png" alt=""> <h2 id="15">PARTE 4</h2><pre class="codeinput">x=@(t) ((t).*(t&gt;=0 ))
h=@(t) ((0).*(t&gt;3))
y=@(t) (((-t)+6).*(t&gt;=3))
t= (0:1:6);
hold <span class="string">off</span>
stem (t,x(t-6));
hold <span class="string">on</span>
stem (t,y(t-6));
hold <span class="string">off</span>
</pre><pre class="codeoutput">
x =

  function_handle with value:

    @(t)((t).*(t&gt;=0))


h =

  function_handle with value:

    @(t)((0).*(t&gt;3))


y =

  function_handle with value:

    @(t)(((-t)+6).*(t&gt;=3))

</pre><img vspace="5" hspace="5" src="practica2_08.png" alt=""> <h2 id="16">PARTE 5</h2><pre class="codeinput">x=@(t) ((t).*(t&gt;=0 ))
h=@(t) ((0).*(t&gt;3))
y=@(t) (((-t)+6).*(t&gt;=3))
t= (0:1:6);
hold <span class="string">off</span>
stem (t,x(3*t));
hold <span class="string">on</span>
stem (t,y(3*t));
hold <span class="string">off</span>
</pre><pre class="codeoutput">
x =

  function_handle with value:

    @(t)((t).*(t&gt;=0))


h =

  function_handle with value:

    @(t)((0).*(t&gt;3))


y =

  function_handle with value:

    @(t)(((-t)+6).*(t&gt;=3))

</pre><img vspace="5" hspace="5" src="practica2_09.png" alt=""> <h2 id="17">PARTE 6</h2><pre class="codeinput">x=@(t) ((t).*(t&gt;=0 ))
h=@(t) ((0).*(t&gt;3))
y=@(t) (((-t)+6).*(t&gt;=3))
t= (0:1:6);
hold <span class="string">off</span>
stem (t,x(t/3));
hold <span class="string">on</span>
stem (t,y(t/3));
hold <span class="string">off</span>
</pre><pre class="codeoutput">
x =

  function_handle with value:

    @(t)((t).*(t&gt;=0))


h =

  function_handle with value:

    @(t)((0).*(t&gt;3))


y =

  function_handle with value:

    @(t)(((-t)+6).*(t&gt;=3))

</pre><img vspace="5" hspace="5" src="practica2_10.png" alt=""> <h2 id="18">PARTE 7</h2><pre class="codeinput">x=@(t) ((t).*(t&gt;=0 ))
h=@(t) ((0).*(t&gt;3))
y=@(t) (((-t)+6).*(t&gt;=3))
t= (0:1:6);
hold <span class="string">off</span>
stem (t,x(3-t));
hold <span class="string">on</span>
stem (t,y(3-t));
hold <span class="string">off</span>
</pre><pre class="codeoutput">
x =

  function_handle with value:

    @(t)((t).*(t&gt;=0))


h =

  function_handle with value:

    @(t)((0).*(t&gt;3))


y =

  function_handle with value:

    @(t)(((-t)+6).*(t&gt;=3))

</pre><img vspace="5" hspace="5" src="practica2_11.png" alt=""> <h2 id="19">Problema 2</h2><p>Cree una funci&oacute;n que gr&aacute;fique funciones de f:Z-R. Resuelva el problema 3.3.7 de Lathi: Encuentre y grafique los componentes pares e impares de: u(n) nu(n) sin((pi*n)/4) cos ((pi*n)/4)</p><h2 id="20">Parte 1</h2><pre class="codeinput">u=@(n) (n&gt;=0);
x2=@(n) 0.5*(u(n)+u(-n));
x3=@(n) 0.5*(u(n)-u(-n));
figure
stem(n,x2(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Par'</span>)
figure
stem(n,u(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Impar'</span>)
</pre><img vspace="5" hspace="5" src="practica2_12.png" alt=""> <img vspace="5" hspace="5" src="practica2_13.png" alt=""> <h2 id="21">Parte 2</h2><pre class="codeinput">nu1=@(n) (n&gt;=0);
x2=@(n) 0.5*(nu1(n)+nu1(-n));
x3=@(n) 0.5*(u(n)-u(-n));
figure
stem(n,nu1(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Par'</span>)
figure
stem(n,nu1(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Impar'</span>)
<span class="comment">%%Parte 3</span>
x4=@(n) sin((pi*n)/4);
x2=@(n) 0.5*(x4(n)+x4(-n));
x3=@(n) 0.5*(x4(n)-x4(-n));
figure
stem(n,x2(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Par'</span>)
figure
stem(n,x3(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Impar'</span>)
<span class="comment">%%Parte 4</span>
x5=@(n) cos((pi*n)/4);
x2=@(n) 0.5*(x5(n)+x5(-n));
x3=@(n) 0.5*(x5(n)-x5(-n));
figure
stem(n,x2(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Par'</span>)
figure
stem(n,x3(n));
grid <span class="string">on</span>
title(<span class="string">'Parte Impar'</span>)
</pre><img vspace="5" hspace="5" src="practica2_14.png" alt=""> <img vspace="5" hspace="5" src="practica2_15.png" alt=""> <img vspace="5" hspace="5" src="practica2_16.png" alt=""> <img vspace="5" hspace="5" src="practica2_17.png" alt=""> <img vspace="5" hspace="5" src="practica2_18.png" alt=""> <img vspace="5" hspace="5" src="practica2_19.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Practica 2: Señales en tiempo discreto.
%
% Integrantes:
%
% * Betanzos Ferrando Melvin Emiliano
%
% * García Becerril Luis Ángel Ian
%
% * Rosales Perez Paola Monserrat
%
% Grupo: 2MV1
%
%%Objetivos:
% Manipulación básica de MATLAB
% Gráficas de señales reales y complejas discretas
% Transformación de señales discretas (escalamientos y traslaciones
%% Introduccion 
% El escalamiento horizontal es una operación que se le aplica a una señal base para generar una señal nueva. Analiticamente un escalamiento horizontal tiene la forma:
%%
% g[n]=hEb{f[n]}=f[bn].
%%
% El escalamiento horizontal nos puede arrojar dos resulados, una compresión o una expansión de la señal.
% Visualmente se podria suponer que cuando vemos una expresión de este tipo f(n)=2n damos por hecho que la señal se duplicará, sin embargo ocurre todo lo contrario.
% Si tenemos una b>1 tendremos una compresión y esto implica que podamos tener una perdida de "datos", esta perdida de datos dependera del valor de b, ya que solo se conservaran las b-ésimas muestras b+N, es decir solo multiplos de b.
%% 
% A continuación se muestra un ejemplo de escalonamiento cuando b>1, en
% este caso se tiene una función f(n)=n y con base en esta se busca generar
% una señal g(n)=f(2n).
%%
f=@(n) n.*(n>=0);
figure
n=-10:10;
stem(n,f(n));
grid on
ylabel('f(n)')
xlabel('n')
title('Función original f(n)=n')
g=@(n) (2.*n).*(2.*n>=0);
figure
n=-10:10;
stem(n,g(n))
grid on
ylabel('g(n)')
xlabel('n')
title('Función escalonada g(n)=2n')
%%
% Podemos ver como se pierde información de los valores n={3,5,7,..}.
%% 
% Cuando 0<b<1 tenemos una expansión de la señal. Lo que sucede en estos casos es que se generan huecos en la señal, es decir, en vez de perder información nos faltaria información, esto ocurre debido a que si recordamos, las señales discretas por norma se evaluan en valores enteros.
% Para ejemplificar este tipo de escalonamiento usaremos una función h(n)=1
% cuando se cumpla la siguiente condición: -3<=n<=1 y se busca hacer un
% escalamiento y(n)=h(0.5n).
%%
h=@(n) n.*(n<=1);
figure
n=-5:5;
stem(n,h(n));
grid on
ylabel('h(n)')
xlabel('n')
title('Función original h(n)=n')
y=@(n) ((0.5).*n).*(n<=2);
figure
n=-5:5;
stem(n,y(n));
grid on
ylabel('y(n)')
xlabel('n')
title('Función escalonada y(n)=n')
%%
% Podemos resaltar la información más importante en los siguientes puntos.
% *Se pierden datos cuando se comprime, sólo podemos
% ver múltiplos del valor de compresión (siempre entero).
% * Cuando expandimos, tenemos la señal completa.
%
%% PROBLEMA 1
%% PARTE 1
% Para x[n] grafique las siguientes señales:
%
x=@(t) ((t).*(t>=0 ))
h=@(t) ((0).*(t>3))
y=@(t) (((-t)+6).*(t>=3))
t= (0:1:6);
hold off
stem (t,x(t));
hold on
stem (t,y(t));
hold off
%% PARTE 2
%
x=@(t) ((t).*(t>=0 ))
h=@(t) ((0).*(t>3))
y=@(t) (((-t)+6).*(t>=3))
t= (0:1:6);
hold off
stem (t,x(-t));
hold on
stem (t,y(-t));
hold off
%% PARTE 3
x=@(t) ((t).*(t>=0 ))
h=@(t) ((0).*(t>3))
y=@(t) (((-t)+6).*(t>=3))
t= (0:1:6);
hold off
stem (t,x(t+6));
hold on
stem (t,y(t+6));
hold off
%% PARTE 4
x=@(t) ((t).*(t>=0 ))
h=@(t) ((0).*(t>3))
y=@(t) (((-t)+6).*(t>=3))
t= (0:1:6);
hold off
stem (t,x(t-6));
hold on
stem (t,y(t-6));
hold off
%% PARTE 5 
x=@(t) ((t).*(t>=0 ))
h=@(t) ((0).*(t>3))
y=@(t) (((-t)+6).*(t>=3))
t= (0:1:6);
hold off
stem (t,x(3*t));
hold on
stem (t,y(3*t));
hold off
%% PARTE 6
x=@(t) ((t).*(t>=0 ))
h=@(t) ((0).*(t>3))
y=@(t) (((-t)+6).*(t>=3))
t= (0:1:6);
hold off
stem (t,x(t/3));
hold on
stem (t,y(t/3));
hold off
%% PARTE 7
x=@(t) ((t).*(t>=0 ))
h=@(t) ((0).*(t>3))
y=@(t) (((-t)+6).*(t>=3))
t= (0:1:6);
hold off
stem (t,x(3-t));
hold on
stem (t,y(3-t));
hold off
%% Problema 2 
% Cree una función que gráfique funciones de f:Z-R.
% Resuelva el problema 3.3.7 de Lathi:
% Encuentre y grafique los componentes pares e impares de:
% u(n)
% nu(n)
% sin((pi*n)/4)
% cos ((pi*n)/4)
%% Parte 1
u=@(n) (n>=0);
x2=@(n) 0.5*(u(n)+u(-n));
x3=@(n) 0.5*(u(n)-u(-n));
figure
stem(n,x2(n));
grid on
title('Parte Par')
figure
stem(n,u(n));
grid on
title('Parte Impar')
%% Parte 2
nu1=@(n) (n>=0);
x2=@(n) 0.5*(nu1(n)+nu1(-n));
x3=@(n) 0.5*(u(n)-u(-n));
figure
stem(n,nu1(n));
grid on
title('Parte Par')
figure
stem(n,nu1(n));
grid on
title('Parte Impar')
%%Parte 3
x4=@(n) sin((pi*n)/4);
x2=@(n) 0.5*(x4(n)+x4(-n));
x3=@(n) 0.5*(x4(n)-x4(-n));
figure
stem(n,x2(n));
grid on
title('Parte Par')
figure
stem(n,x3(n));
grid on
title('Parte Impar')
%%Parte 4
x5=@(n) cos((pi*n)/4);
x2=@(n) 0.5*(x5(n)+x5(-n));
x3=@(n) 0.5*(x5(n)-x5(-n));
figure
stem(n,x2(n));
grid on
title('Parte Par')
figure
stem(n,x3(n));
grid on
title('Parte Impar')
##### SOURCE END #####
--></body></html>